<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ê´€ë¦¬ì Â· ë°°ë“œë¯¼í„´ í† ë„ˆë¨¼íŠ¸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- ê°œë°œì—ì„  SW ë¹„í™œì„±/ìºì‹œì²­ì†Œ, ë°°í¬ì—ì„œë§Œ ë“±ë¡ -->
  <script>
    const isLocal = ["localhost","127.0.0.1"].includes(location.hostname);
    if ("serviceWorker" in navigator) {
      if (!isLocal) {
        window.addEventListener("load", () => navigator.serviceWorker.register("./sw.js"));
      } else {
        navigator.serviceWorker?.getRegistrations?.().then(rs => rs.forEach(r => r.unregister()));
        caches?.keys?.().then(keys => keys.forEach(k => caches.delete(k)));
      }
    }
  </script>

  <!-- UI / SDK -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script src="./config.js"></script>

  <!-- Pantone Theme -->
  <style>
    :root{
      --brand-25:#fbf7f5;--brand-100:#efe3dc;--brand-200:#e3cfc4;--brand-300:#d2b6a9;--brand-400:#bf9b8e;--brand-500:#b18474;--brand-600:#a47864;--brand-700:#8f6655;--brand-800:#6f4f45;--brand-900:#4f3a32;--brand-contrast:#ffffff;
      --info-100:#e7eef5;--info-700:#0F4C81;--success-100:#e8f7ef;--success-700:#15803d;--danger-100:#fde7eb;--danger-700:#be3455;
      --chip-bg:var(--brand-100);--chip-fg:#3b2f2a;
    }
    .btn-primary{background:var(--brand-600);color:var(--brand-contrast)}
    .btn-primary:hover{filter:brightness(0.95)}
    .btn-outline{border:1px solid var(--brand-300);background:#fff;color:var(--brand-800)}
    .btn-outline:hover{border-color:var(--brand-400);background:var(--brand-25)}
    .brand-card{border-color:var(--brand-200)}
    .lock-scroll{overflow:hidden}
    .chip{background:var(--chip-bg);color:var(--chip-fg)}
    .chip-info{background:var(--info-100);color:var(--info-700)}
    .chip-success{background:var(--success-100);color:var(--success-700)}
    .chip-danger{background:var(--danger-100);color:var(--danger-700)}
    .icon-btn{width:28px;height:28px;display:flex;align-items:center;justify-content:center;border:1px solid var(--brand-300);border-radius:.5rem}
    .icon-btn:hover{background:var(--brand-25)}
    .scorebox{width:52px}
    .scoregroup{display:flex;align-items:center;gap:.25rem}
    .state-dot{width:8px;height:8px;border-radius:9999px;display:inline-block;margin-right:.4rem}
    /* === Admin í…Œì´ë¸” ë ˆì´ì•„ì›ƒ ë³´ì • === */
    .admin-table { table-layout: fixed; }
    .admin-table th, .admin-table td { vertical-align: top; }

    /* ê³ ì • ì»¬ëŸ¼ í­ */
    .col-id{width:56px}
    .col-stage{width:84px}
    .col-group{width:92px}
    .col-ab{width:260px}
    .col-sets{width:260px}
    .col-state{width:220px}
    .col-court{width:140px}
    .col-actions{width:200px}

    @media (max-width:1140px){
      .col-actions{width:160px}
      .col-state{width:200px}
    }

    /* ì ìˆ˜ ì¸í’‹ í­ ì‚´ì§ ì¤„ì—¬ í…Œì´ë¸”ì— ë§ì¶¤ */
    .scorebox{width:48px}
  </style>
</head>
<body class="bg-slate-50 text-slate-900">
  <!-- Page Loading -->
  <div id="pageLoading" class="fixed inset-0 z-50 hidden items-center justify-center bg-white/80 backdrop-blur">
    <div class="flex flex-col items-center gap-3">
      <div class="h-10 w-10 rounded-full border-4 border-slate-300 border-t-slate-700 animate-spin"></div>
      <div class="text-sm text-slate-600">ë¡œë”© ì¤‘â€¦</div>
    </div>
  </div>

  <!-- Saving -->
  <div id="savingOverlay" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/30">
    <div class="bg-white rounded-xl shadow-lg px-4 py-3 flex items-center gap-3">
      <div class="h-5 w-5 rounded-full border-2 border-slate-300 border-t-slate-700 animate-spin"></div>
      <div class="text-sm text-slate-700">ì €ì¥ ì¤‘â€¦</div>
    </div>
  </div>

  <!-- Header -->
  <header class="sticky top-0 z-40 bg-white/90 backdrop-blur border-b border-slate-200">
    <div class="max-w-6xl mx-auto px-3 py-2 flex items-center justify-between">
      <h1 class="text-lg md:text-xl font-bold">ğŸ› ï¸ ê´€ë¦¬ì</h1>
      <nav class="flex items-center gap-2">
        <a href="./index.html" class="rounded px-3 py-2 btn-outline text-sm">ë©”ì¸</a>
        <a href="./referee.html" class="rounded px-3 py-2 btn-outline text-sm">ì‹¬íŒ í™”ë©´</a>
      </nav>
    </div>
  </header>

  <!-- Main -->
  <main class="max-w-6xl mx-auto px-3 py-4 space-y-4">

    <!-- íŒ€/ì„ ìˆ˜ í¸ì§‘ -->
    <section class="rounded-2xl border brand-card bg-white shadow-sm">
      <div class="px-3 py-2 border-b brand-card flex items-center justify-between">
        <h2 class="font-semibold">íŒ€ / ì„ ìˆ˜ í¸ì§‘</h2>
        <div class="flex items-center gap-2">
          <input id="teamSearch" placeholder="ê²€ìƒ‰(íŒ€/ì„ ìˆ˜)" class="rounded border brand-card px-2 py-1 text-sm w-44">
          <button id="btnNewTeam" class="rounded px-3 py-2 text-sm btn-primary">ìƒˆ íŒ€ ì¶”ê°€</button>
          <button id="btnBulk" class="rounded px-3 py-2 text-sm btn-outline">ëŒ€ëŸ‰ ë“±ë¡</button>
        </div>
      </div>
      <div class="p-3">
        <div id="teamsEditor" class="grid grid-cols-1 md:grid-cols-2 gap-3"></div>
      </div>
    </section>

    <!-- í™˜ê²½ ëª¨ë“œ -->
    <section class="rounded-2xl border brand-card bg-white shadow-sm">
      <div class="px-3 py-2 border-b brand-card">
        <h2 class="font-semibold">í™˜ê²½ ëª¨ë“œ</h2>
      </div>
      <div class="p-3 flex flex-col gap-2">
        <p class="text-sm text-slate-600">ê°œë°œ ëª¨ë“œ: í´ë¼ì´ì–¸íŠ¸ CRUD í—ˆìš© Â· ìš´ì˜ ëª¨ë“œ: ì½ê¸°ë§Œ, ì“°ê¸°ëŠ” ë³´ì•ˆ RPCë§Œ í—ˆìš©</p>
        <div class="flex flex-wrap items-center gap-2">
          <input id="adminSecret" type="password" placeholder="ê´€ë¦¬ì ë¹„ë°€í‚¤" class="w-56 rounded border brand-card px-2 py-1 text-sm"/>
          <button id="btnModeDev" class="rounded px-3 py-2 text-sm btn-outline">ê°œë°œ ëª¨ë“œ ì „í™˜</button>
          <button id="btnModeProd" class="rounded px-3 py-2 text-sm btn-primary">ìš´ì˜ ëª¨ë“œ ì „í™˜</button>
        </div>
      </div>
    </section>

    <!-- ìœ„í—˜ êµ¬ì—­ -->
    <section class="rounded-2xl border brand-card bg-white shadow-sm">
      <div class="px-3 py-2 border-b brand-card flex items-center justify-between">
        <h2 class="font-semibold text-rose-700">ìœ„í—˜: ì „ì²´ ì´ˆê¸°í™”</h2>
      </div>
      <div class="p-3 flex flex-col gap-2">
        <p class="text-sm text-slate-600">ëª¨ë“  ê²½ê¸°/ì„¸íŠ¸/ê·¸ë£¹/íŒ€/ì„ ìˆ˜ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³  ì‹œí€€ìŠ¤ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
        <div class="flex items-center gap-2">
          <input id="hardResetKey" type="password" placeholder="ê´€ë¦¬ì ë¹„ë°€í‚¤" class="w-56 rounded border brand-card px-2 py-1 text-sm"/>
          <button id="btnHardReset" class="rounded px-3 py-2 text-sm" style="background:var(--danger-100);color:var(--danger-700);border:1px solid var(--danger-700)">ì „ì²´ ì´ˆê¸°í™”</button>
        </div>
      </div>
    </section>

    <!-- ì¡° êµ¬ì„± -->
    <section class="rounded-2xl border brand-card bg-white shadow-sm">
      <div class="px-3 py-2 border-b brand-card flex items-center justify-between">
        <h2 class="font-semibold">ì¡° êµ¬ì„±</h2>
        <div class="flex gap-2">
          <input id="teamsPerGroup" type="number" min="3" max="6" value="4" class="w-20 rounded border brand-card px-2 py-1 text-sm"/>
          <button id="btnAutoGroups" class="rounded px-3 py-2 btn-primary text-sm">ìë™(A..F) ë°°ì •</button>
          <button id="btnWipeGroups" class="rounded px-3 py-2 text-sm btn-outline">ê·¸ë£¹/ì†Œì† ì‚­ì œ</button>
        </div>
      </div>
      <div class="p-3"><div id="groupsList" class="text-sm text-slate-600">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</div></div>
    </section>

    <!-- ê²½ê¸° ìƒì„±/ê´€ë¦¬ -->
    <section class="rounded-2xl border brand-card bg-white shadow-sm">
      <div class="px-3 py-2 border-b brand-card flex items-center justify-between">
        <h2 class="font-semibold">ê²½ê¸° ìƒì„±/ê´€ë¦¬</h2>
        <div class="flex flex-wrap items-center gap-2">
          <button id="btnRR" class="rounded px-3 py-2 btn-primary text-sm">ì¡°ë³„ ë¦¬ê·¸ ìƒì„±</button>
          <button id="btnKO" class="rounded px-3 py-2 btn-outline text-sm">8ê°•/4ê°•/ê²°ìŠ¹ ìƒì„±</button>
          <button id="btnWipeMatches" class="rounded px-3 py-2 text-sm btn-outline">ëª¨ë“  ê²½ê¸°/ì„¸íŠ¸ ì‚­ì œ</button>
        </div>
      </div>

      <div class="p-3">
        <!-- ê³µí†µ íŒŒë¼ë¯¸í„° + ì¼ê´„ ë²„íŠ¼ -->
        <div class="flex flex-wrap items-center gap-2 mb-2">
          <input id="defaultPtw" type="number" min="11" value="25" class="w-24 rounded border brand-card px-2 py-1 text-sm"/><span class="text-sm text-slate-600">Points To Win</span>
          <input id="defaultBo" type="number" min="1" value="1" class="w-20 rounded border brand-card px-2 py-1 text-sm"/><span class="text-sm text-slate-600">Best Of</span>
          <input id="defaultWinBy" type="number" min="0" value="1" class="w-20 rounded border brand-card px-2 py-1 text-sm"/><span class="text-sm text-slate-600">Win By</span>
          <input id="koAdvPerGroup" type="number" min="1" value="1" class="w-20 rounded border brand-card px-2 py-1 text-sm"/><span class="text-sm text-slate-600">ì¡°ë‹¹ ì§„ì¶œ</span>
          <input id="manualSeeds" type="text" placeholder="ìˆ˜ë™ ì‹œë“œ(íŒ€ID ì½¤ë§ˆ)" class="w-60 rounded border brand-card px-2 py-1 text-sm" />
          <button id="btnBulkDone" class="px-3 py-2 rounded btn-outline text-sm">ì¼ê´„ done ì²˜ë¦¬</button>
          <button id="btnBulkFinalize" class="px-3 py-2 rounded btn-outline text-sm">ì¼ê´„ ì™„ë£Œ ì²˜ë¦¬</button>
        </div>

        <!-- ëª¨ë°”ì¼: ì¹´ë“œ ëª©ë¡ -->
        <div id="matchesCards" class="md:hidden space-y-3"></div>

        <!-- ë°ìŠ¤í¬í†±: í…Œì´ë¸” -->
        <div id="matchesTblWrap" class="hidden md:block overflow-x-auto rounded border brand-card">
          <table class="admin-table min-w-[1080px] w-full text-sm">
            <colgroup>
              <col class="col-id"/><col class="col-stage"/><col class="col-group"/>
              <col class="col-ab"/><col class="col-sets"/><col class="col-state"/>
              <col class="col-court"/><col class="col-actions"/>
            </colgroup>
            <thead>
              <tr class="bg-[color:var(--brand-25)]">
                <th class="p-2 text-left">ID</th>
                <th class="p-2 text-left">Stage</th>
                <th class="p-2 text-left">Group</th>
                <th class="p-2 text-left">A vs B</th>
                <th class="p-2 text-left">ì„¸íŠ¸/ì ìˆ˜</th>
                <th class="p-2 text-left">ìƒíƒœ</th>
                <th class="p-2 text-left">Court</th>
                <th class="p-2 text-left">ì•¡ì…˜</th>
              </tr>
            </thead>
            <tbody id="matchesTbody" class="divide-y"></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>

  <!-- ëŒ€ëŸ‰ë“±ë¡ ëª¨ë‹¬ -->
  <div id="bulkModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/40">
    <div class="bg-white rounded-2xl w-[min(720px,95vw)] p-4">
      <div class="flex items-center justify-between mb-2">
        <h3 class="font-semibold">ëŒ€ëŸ‰ ë“±ë¡</h3>
        <button class="icon-btn" onclick="closeBulk()">âœ•</button>
      </div>
      <p class="text-sm text-slate-600 mb-2">í˜•ì‹: <span class="font-mono">íŒ€ëª…, ì„ ìˆ˜1, ì„ ìˆ˜2, ...</span> (í•œ ì¤„ = í•œ íŒ€)</p>
      <textarea id="bulkText" rows="8" class="w-full rounded border brand-card p-2 font-mono text-sm" placeholder="íŒ€A, í™ê¸¸ë™, ê¹€ì˜í¬&#10;íŒ€B, ë°•ë¯¼ìˆ˜, ì´ì˜í¬"></textarea>
      <div class="mt-3 flex items-center gap-2">
        <button class="btn-outline rounded px-3 py-2 text-sm" onclick="bulkPreview()">ë¯¸ë¦¬ë³´ê¸°</button>
        <button class="btn-primary rounded px-3 py-2 text-sm" onclick="bulkSave()">ì €ì¥</button>
        <div id="bulkStatus" class="text-sm text-slate-600 ml-auto"></div>
      </div>
      <div id="bulkPreviewBox" class="mt-3 text-sm"></div>
    </div>
  </div>

  <script>
    // ===== Helpers =====
    const $ = (s)=>document.querySelector(s);
    const show = (el)=>el.classList.remove("hidden");
    const hide = (el)=>el.classList.add("hidden");
    const startPage = ()=>{ show($("#pageLoading")); document.body.classList.add("lock-scroll"); };
    const endPage   = ()=>{ hide($("#pageLoading")); document.body.classList.remove("lock-scroll"); };
    const startSaving=()=>{ show($("#savingOverlay")); document.body.classList.add("lock-scroll"); };
    const endSaving  =()=>{ hide($("#savingOverlay")); document.body.classList.remove("lock-scroll"); };

    const sb = supabase.createClient(window.APP_CONFIG.SUPABASE_URL, window.APP_CONFIG.SUPABASE_ANON_KEY);

    // ===== TEAM EDITOR (ì›ë³¸ ìœ ì§€, ì¼ë¶€ í•¨ìˆ˜ ìƒëµ ì—†ì´ í¬í•¨) =====
    let TEAM_CACHE=[]; let NEW_COUNTER=0;
    function normalizeTeams(rows){
      return (rows||[]).map(t=>{
        const members=(t.team_members||[]).map(tm=>({id:tm.players?.id||tm.player_id,name:tm.players?.name||""}));
        return {id:t.id,name:t.name,pin:t.pin||"",members};
      });
    }
    async function loadTeams(){
      const {data,error}=await sb.from("teams").select("id,name,pin, team_members(player_id, players(id,name))").order("name",{ascending:true});
      if(error){ $("#teamsEditor").innerHTML=`<div class="text-rose-600 text-sm">${error.message}</div>`; return; }
      TEAM_CACHE=normalizeTeams(data); renderTeamEditor();
    }
    function memberRow(teamDomId,pid,name){ return `
      <div class="flex items-center gap-2 roster-row" data-pid="${pid||""}">
        <input class="player-name flex-1 rounded border brand-card px-2 py-1 bg-white" placeholder="ì„ ìˆ˜ ì´ë¦„" value="${name||""}">
        <button class="icon-btn" title="ì‚­ì œ" onclick="removeMemberRow(this)">ğŸ—‘</button>
      </div>`; }
    function teamCard(t){
      const tid=t.id??`new-${++NEW_COUNTER}`;
      const membersHtml=(t.members?.length?t.members:[{id:"",name:""},{id:"",name:""}]).map(m=>memberRow(tid,m.id,m.name)).join("");
      return `
        <div class="rounded-2xl border brand-card p-3 bg-[color:var(--brand-25)]" data-team="${tid}">
          <div class="flex items-center gap-2">
            <input class="team-name flex-1 rounded border brand-card px-2 py-1 text-sm bg-white" placeholder="íŒ€ëª…" value="${t.name||""}">
            <input class="team-pin w-28 rounded border brand-card px-2 py-1 text-sm bg-white" placeholder="PIN(ì„ íƒ)" value="${t.pin||""}">
            ${t.id?`<span class="text-xs text-slate-500">#${t.id}</span>`:`<span class="text-xs chip px-2 py-0.5 rounded">ìƒˆ íŒ€</span>`}
          </div>
          <div class="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-2" id="roster_${tid}">${membersHtml}</div>
          <div class="mt-2 flex items-center gap-2">
            <button class="icon-btn" title="ì„ ìˆ˜ ì¶”ê°€" onclick="addMemberRow('${tid}')">ï¼‹</button>
            <div class="ml-auto flex items-center gap-2">
              <button class="btn-outline rounded px-3 py-2 text-sm" onclick="saveTeam('${tid}')">ì €ì¥</button>
              ${t.id?`<button class="rounded px-3 py-2 text-sm" style="border:1px solid var(--danger-700);color:var(--danger-700)" onclick="deleteTeam(${t.id})">ì‚­ì œ</button>`:""}
            </div>
          </div>
        </div>`;
    }
    function renderTeamEditor(filter=""){
      const q=filter.trim().toLowerCase();
      const list=q?TEAM_CACHE.filter(t=>(t.name||"").toLowerCase().includes(q)||(t.members||[]).some(m=>(m.name||"").toLowerCase().includes(q))):TEAM_CACHE;
      $("#teamsEditor").innerHTML=list.length?list.map(teamCard).join(""):`<div class="text-slate-500">íŒ€ì´ ì—†ìŠµë‹ˆë‹¤. 'ìƒˆ íŒ€ ì¶”ê°€'ë¥¼ ëˆŒëŸ¬ ë“±ë¡í•˜ì„¸ìš”.</div>`;
    }
    function addMemberRow(teamDomId){ const host=document.getElementById(`roster_${teamDomId}`); host.insertAdjacentHTML("beforeend",memberRow(teamDomId,"","")); }
    function removeMemberRow(btn){ btn.closest(".roster-row")?.remove(); }
    function newTeam(){ const t={id:null,name:"",pin:"",members:[{id:"",name:""},{id:"",name:""}]}; TEAM_CACHE.unshift(t); renderTeamEditor($("#teamSearch").value||""); }
    async function saveTeam(teamDomId){
      const card=document.querySelector(`[data-team="${teamDomId}"]`); if(!card) return;
      const name=card.querySelector(".team-name").value.trim(); const pin=card.querySelector(".team-pin").value.trim()||null;
      if(!name){ alert("íŒ€ëª…ì„ ì…ë ¥í•˜ì„¸ìš”."); return; }
      let dbId=/^\d+$/.test(teamDomId)?parseInt(teamDomId,10):null;
      startSaving();
      try{
        if(!dbId){ const {data:ins,error:errT}=await sb.from("teams").insert({name,pin}).select("id").single(); if(errT) throw errT; dbId=ins.id; }
        else{ const {error:errU}=await sb.from("teams").update({name,pin}).eq("id",dbId); if(errU) throw errU; }
        const rows=[...card.querySelectorAll(".roster-row")];
        for(const row of rows){
          const pid=row.getAttribute("data-pid"); const pname=row.querySelector(".player-name").value.trim();
          if(pid){ if(!pname){ await sb.from("team_members").delete().eq("team_id",dbId).eq("player_id",pid); } else { await sb.from("players").update({name:pname}).eq("id",pid); } }
          else if(pname){ const {data:pIns,error:pErr}=await sb.from("players").insert({name:pname}).select("id").single(); if(pErr) throw pErr; await sb.from("team_members").insert({team_id:dbId,player_id:pIns.id}); }
        }
        await loadTeams(); alert("ì €ì¥ ì™„ë£Œ");
      }catch(e){ console.error(e); alert("ì €ì¥ ì‹¤íŒ¨: "+(e.message||e)); }
      finally{ endSaving(); }
    }
    async function deleteTeam(id){ if(!confirm("ì •ë§ ì´ íŒ€ì„ ì‚­ì œí• ê¹Œìš”? (ê²½ê¸° ê¸°ë¡ì´ ìˆìœ¼ë©´ ì‚­ì œë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤)")) return; startSaving(); try{ await sb.from("teams").delete().eq("id",id); await loadTeams(); } finally{ endSaving(); } }
    $("#teamSearch").addEventListener("input",(e)=>renderTeamEditor(e.target.value));
    window.addMemberRow=addMemberRow; window.removeMemberRow=removeMemberRow; window.saveTeam=saveTeam; window.deleteTeam=deleteTeam;
    document.getElementById("btnNewTeam").addEventListener("click",newTeam);

    // ===== Bulk insert =====
    function openBulk(){ $("#bulkText").value=""; $("#bulkPreviewBox").innerHTML=""; $("#bulkStatus").textContent=""; show($("#bulkModal")); }
    function closeBulk(){ hide($("#bulkModal")); }
    function parseBulk(text){ return text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean).map(line=>{ const tokens=line.split(/[,|\t]/).map(s=>s.trim()).filter(Boolean); const team=tokens.shift()||""; return {team,members:tokens}; }).filter(x=>x.team); }
    function bulkPreview(){ const parsed=parseBulk($("#bulkText").value||""); $("#bulkPreviewBox").innerHTML=parsed.length?`<div class="space-y-1">${parsed.map(p=>`<div>â€¢ <b>${p.team}</b> â€” ${p.members.join(", ")||"(ì„ ìˆ˜ ì—†ìŒ)"}</div>`).join("")}</div>`:`<div class="text-slate-500">ë¯¸ë¦¬ë³¼ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.</div>`; }
    async function bulkSave(){
      const parsed=parseBulk($("#bulkText").value||""); if(!parsed.length){ alert("ë¶™ì—¬ë„£ì€ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤."); return; }
      startSaving();
      try{
        let ok=0;
        for(const item of parsed){
          const {data:t,error:te}=await sb.from("teams").insert({name:item.team}).select("id").single(); if(te) throw te;
          for(const nm of item.members){ const {data:p,error:pe}=await sb.from("players").insert({name:nm}).select("id").single(); if(pe) throw pe; await sb.from("team_members").insert({team_id:t.id,player_id:p.id}); }
          ok++; $("#bulkStatus").textContent=`${ok}/${parsed.length} ì €ì¥â€¦`;
        }
        await loadTeams(); $("#bulkStatus").textContent="ì™„ë£Œ"; alert("ëŒ€ëŸ‰ ë“±ë¡ ì™„ë£Œ"); closeBulk();
      }catch(e){ console.error(e); alert("ëŒ€ëŸ‰ ë“±ë¡ ì‹¤íŒ¨: "+(e.message||e)); }
      finally{ endSaving(); }
    }
    document.getElementById("btnBulk").addEventListener("click",openBulk);
    window.closeBulk=closeBulk; window.bulkPreview=bulkPreview; window.bulkSave=bulkSave;

    // ===== Groups =====
    async function loadGroups(){
      try{
        const {data:groups,error:gErr}=await sb.from("groups").select("*").order("name");
        if(gErr) throw gErr;
        if(!groups?.length){
          $("#groupsList").innerHTML=`<div class="text-slate-500">ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
          return;
        }

        // íŒ€ì›ê¹Œì§€ í•¨ê»˜ ê°€ì ¸ì˜´
        const {data:gt, error:gtErr} = await sb
          .from("group_teams")
          .select("group_id, team_id, teams(id,name, team_members(players(name)))")
          .order("group_id");
        if(gtErr) throw gtErr;

        const byG=new Map(); for(const g of groups) byG.set(g.id,[]);
        for(const r of gt||[]) byG.get(r.group_id)?.push(r);

        // íŒ€ëª… + íŒ€ì›(ì½¤ë§ˆ êµ¬ë¶„) ì¶œë ¥
        $("#groupsList").innerHTML = `
          <div class="space-y-2">
            ${groups.map(g => `
              <div class="rounded border brand-card">
                <div class="px-3 py-2 bg-[color:var(--brand-25)] font-semibold">
                  ì¡° ${g.name} <span class="text-xs text-slate-500">#${g.id}</span>
                </div>
                <div class="p-3 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-2">
                  ${(byG.get(g.id) || []).map(x => {
                    const name = x.teams?.name || ("#"+x.team_id);
                    const roster = (x.teams?.team_members || [])
                      .map(tm => tm.players?.name)
                      .filter(Boolean)
                      .join(", ");
                    return `
                      <div class="rounded border brand-card bg-white p-2">
                        <div class="font-medium truncate" title="${name}">${name}</div>
                        <div class="text-[11px] text-slate-500" title="${roster}">${roster || "&nbsp;"}</div>
                      </div>`;
                  }).join("")}
                </div>
              </div>
            `).join("")}
          </div>`;
      }catch(e){
        console.warn(e);
        $("#groupsList").innerHTML=`<div class="text-rose-600 text-sm">group_teams/groups ì¡°íšŒ ì‹¤íŒ¨: ${e.message||e}</div>`;
      }
    }

    function rrPairs(ids){ const p=[]; for(let i=0;i<ids.length;i++) for(let j=i+1;j<ids.length;j++) p.push([ids[i],ids[j]]); return p; }
    async function autoGroups(){
      const per=Math.max(3,Math.min(6,parseInt($("#teamsPerGroup").value||"4",10)));
      startSaving();
      try{
        const {data:teams}=await sb.from("teams").select("id").order("id");
        if(!teams?.length){ alert("íŒ€ì´ ì—†ìŠµë‹ˆë‹¤."); return; }
        await sb.from("group_teams").delete().neq("group_id",-1);
        await sb.from("groups").delete().neq("id",-1);
        const gcount=Math.ceil(teams.length/per);
        const names=Array.from({length:gcount},(_,i)=>String.fromCharCode(65+i));
        const {data:insGroups}=await sb.from("groups").insert(names.map(n=>({name:n}))).select("*");
        let idx=0, gmap=insGroups.reduce((a,g)=>{a[g.name]=g.id; return a;},{}), rows=[];
        for(const t of teams){ const gName=names[idx%gcount]; rows.push({group_id:gmap[gName],team_id:t.id}); idx++; }
        if(rows.length) await sb.from("group_teams").insert(rows);
      }finally{ endSaving(); await loadGroups(); }
    }
    async function wipeGroups(){
      if(!confirm("ê·¸ë£¹ê³¼ ì†Œì†ì„ ëª¨ë‘ ì‚­ì œí•©ë‹ˆê¹Œ?")) return;
      startSaving(); try{ await sb.from("group_teams").delete().neq("group_id",-1); await sb.from("groups").delete().neq("id",-1); }
      finally{ endSaving(); await loadGroups(); }
    }

    // ===== Matches: ì ìˆ˜í¸ì§‘/ìƒíƒœ/ë¶€ì „ìŠ¹ =====
    function needSetsToWin(bo){ return Math.floor(bo/2)+1; }
    function summarizeState(m, sets){
      const bo = Math.max(1, Number(m.best_of||1));
      let wa=0, wb=0;
      for(const s of sets){ const a=+s.score_a||0, b=+s.score_b||0; if(a===0&&b===0) continue; if(a>b) wa++; else if(b>a) wb++; }
      const need = needSetsToWin(bo);
      let winner_id=null, state='pending', chip='chip';
      if(wa+wb===0){ state='ëŒ€ê¸°'; chip='chip'; }
      else if(wa>=need || wb>=need){
        winner_id = (wa>wb)? m.team_a_id : m.team_b_id;
        state = m.is_final ? 'í™•ì •' : 'ì™„ë£Œ';
        chip = m.is_final ? 'chip-success' : 'chip-danger';
      } else {
        state='ì§„í–‰'; chip='chip-info';
      }
      const text = `${wa}-${wb}(ì„¸íŠ¸)${winner_id?` Â· ${winner_id===m.team_a_id?'A':'B'}íŒ€ ìš°ìŠ¹`:""}`;
      return {wa,wb,need,winner_id,state,chip,text};
    }

    function setInputsInline(m, msets){
      const bo=Math.max(1,Number(m.best_of||1));
      const ptw=Number(m.points_to_win||25);
      const byNo = new Map((msets||[]).map(s=>[s.set_no,s]));
      let html="";
      for(let i=1;i<=bo;i++){
        const a = byNo.get(i)?.score_a ?? "";
        const b = byNo.get(i)?.score_b ?? "";
        html += `
          <div class="flex items-center gap-1">
            <span class="text-xs text-slate-500">S${i}</span>
            <input class="scorebox rounded border brand-card px-1 py-1 text-center" id="sa_${m.id}_${i}" value="${a}">
            <span>-</span>
            <input class="scorebox rounded border brand-card px-1 py-1 text-center" id="sb_${m.id}_${i}" value="${b}">
          </div>`;
      }
      return `<div class="flex flex-wrap items-center gap-2" data-ptw="${ptw}" data-bo="${bo}">${html}</div>`;
    }

    function rowStateChip(obj){
      const dot = obj.state==='ì§„í–‰' ? '#0F4C81'
                : obj.state==='í™•ì •' ? '#15803d'
                : obj.state==='ì™„ë£Œ' ? '#be3455' : '#94a3b8';
      const color = obj.chip;
      return `
        <div class="flex flex-col lg:flex-row lg:items-center gap-1 lg:gap-2 leading-5">
          <span class="state-dot" style="background:${dot}"></span>
          <span class="inline-flex items-center px-2 py-0.5 rounded text-[11px] ${color}">${obj.state}</span>
          <span class="text-[11px] text-slate-500 break-words">${obj.text}</span>
        </div>`;
    }

    async function saveScores(mid){
      const tr = document.querySelector(`tr[data-match-id="${mid}"]`);
      const bo = parseInt(tr?.dataset.bo || "1", 10);
      const ptw = parseInt(tr?.dataset.ptw || "25", 10);

      // ìˆ˜ì§‘
      const sets=[];
      for(let i=1;i<=bo;i++){
        const a = document.getElementById(`sa_${mid}_${i}`)?.value?.trim();
        const b = document.getElementById(`sb_${mid}_${i}`)?.value?.trim();
        if(a!=="" && b!==""){
          const ai = Math.max(0, parseInt(a,10)||0);
          const bi = Math.max(0, parseInt(b,10)||0);
          sets.push({set_no:i, score_a:ai, score_b:bi});
        }
      }

      startSaving();
      try{
        // ì„¸íŠ¸ ì „ëŸ‰ ì¬ê¸°ë¡
        await sb.from("match_sets").delete().eq("match_id", mid);
        if(sets.length){
          await sb.from("match_sets").insert(sets.map(s=>({match_id:mid, ...s})));
        }

        // ìƒíƒœ/ìŠ¹ì ìë™ íŒì •
        const { data:mrow } = await sb.from("matches").select("*").eq("id",mid).single();
        const summary = summarizeState(mrow||{best_of:bo,team_a_id:null,team_b_id:null,is_final:false}, sets);
        await sb.from("matches").update({
          status: (sets.length===0 ? "pending" : (summary.winner_id ? "done" : "live")),
          winner_id: summary.winner_id
        }).eq("id", mid);

        await loadMatches();
      } finally { endSaving(); }
    }

    async function clearScores(mid){
      startSaving();
      try{
        await sb.from("match_sets").delete().eq("match_id", mid);
        await sb.from("matches").update({ status:"pending", winner_id: null }).eq("id", mid);
        await loadMatches();
      } finally { endSaving(); }
    }

    async function walkover(mid, which){
      const tr = document.querySelector(`tr[data-match-id="${mid}"]`);
      const ptw = parseInt(tr?.dataset.ptw || "25", 10);
      const bo  = parseInt(tr?.dataset.bo  || "1", 10);
      // BO1 ê¸°ì¤€ 1ì„¸íŠ¸ë§Œ ê¸°ë¡(BO>1ì´ì–´ë„ ìŠ¹ì íŒì • ê°€ëŠ¥)
      const a = (which==='A') ? ptw : 0;
      const b = (which==='B') ? ptw : 0;
      startSaving();
      try{
        await sb.from("match_sets").delete().eq("match_id", mid);
        await sb.from("match_sets").insert([{ match_id: mid, set_no:1, score_a:a, score_b:b }]);
        await sb.from("matches").update({ status:"done", winner_id: (which==='A') ? (await teamIdsOf(mid)).a : (await teamIdsOf(mid)).b }).eq("id", mid);
        await loadMatches();
      } finally { endSaving(); }
    }
    async function teamIdsOf(mid){
      const {data}=await sb.from("matches").select("team_a_id,team_b_id").eq("id",mid).single();
      return {a:data?.team_a_id, b:data?.team_b_id};
    }

    // ê¸°ì¡´ ë³´ì¡° ë²„íŠ¼ë“¤
    function getVisibleMatchIds(){ const rows=document.querySelectorAll("tbody tr[data-match-id]"); const ids=[]; rows.forEach(tr=>ids.push(+tr.dataset.matchId)); return ids; }
    async function bulkDone(){
      const ids=getVisibleMatchIds(); if(!ids.length) return alert("ì²˜ë¦¬í•  ê²½ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤.");
      if(!confirm(`í˜„ì¬ í™”ë©´ì˜ ${ids.length}ê°œ ê²½ê¸°ë¥¼ doneìœ¼ë¡œ í‘œì‹œí• ê¹Œìš”?`)) return;
      const {error}=await sb.from("matches").update({status:"done"}).in("id",ids).neq("status","done");
      if(error){ console.error(error); return alert("ì¼ê´„ done ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."); }
      alert("ì¼ê´„ done ì²˜ë¦¬ ì™„ë£Œ"); await loadMatches();
    }
    async function bulkFinalize(){
      const ids=getVisibleMatchIds(); if(!ids.length) return alert("ì²˜ë¦¬í•  ê²½ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤.");
      if(!confirm(`í˜„ì¬ í™”ë©´ì˜ ${ids.length}ê°œ ê²½ê¸° ê²°ê³¼ë¥¼ 'ì™„ë£Œ(ìµœì¢… í™•ì •)'ë¡œ ë°˜ì˜í• ê¹Œìš”?\n(done ìƒíƒœë§Œ í™•ì •ë©ë‹ˆë‹¤)`)) return;
      const {error}=await sb.from("matches").update({is_final:true}).in("id",ids).eq("status","done").eq("is_final",false);
      if(error){ console.error(error); return alert("ì¼ê´„ ì™„ë£Œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."); }
      alert("ì¼ê´„ ì™„ë£Œ ì²˜ë¦¬ ì™„ë£Œ"); await loadMatches();
    }
    document.getElementById("btnBulkDone")?.addEventListener("click",bulkDone);
    document.getElementById("btnBulkFinalize")?.addEventListener("click",bulkFinalize);

    // í…Œì´ë¸” + ì¹´ë“œ ë™ì‹œ ë Œë”
    async function loadMatches(){
      const {data:matches, error:mErr}=await sb
        .from("matches")
        .select("*, groups(name)")
        .order("stage").order("group_id").order("id");

      if(mErr){
        $("#matchesTbody").innerHTML=`<tr><td colspan="8" class="p-3 text-rose-600 text-sm">${mErr.message}</td></tr>`;
        $("#matchesCards").innerHTML=`<div class="text-rose-600 text-sm">${mErr.message}</div>`;
        return;
      }
      if(!matches?.length){
        $("#matchesTbody").innerHTML=`<tr><td colspan="8" class="p-3 text-slate-500">ê²½ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤.</td></tr>`;
        $("#matchesCards").innerHTML=`<div class="text-slate-500">ê²½ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>`;
        return;
      }

      const [{data:teams},{data:msets}] = await Promise.all([
        sb.from("teams").select("id,name"),
        sb.from("match_sets").select("match_id,set_no,score_a,score_b")
      ]);
      const tmap=new Map((teams||[]).map(t=>[t.id,t.name]));
      const setMap=new Map(); for(const s of (msets||[])){ if(!setMap.has(s.match_id)) setMap.set(s.match_id,[]); setMap.get(s.match_id).push(s); }

      // ===== 2-1) ë°ìŠ¤í¬í†± í…Œì´ë¸” =====
      $("#matchesTbody").innerHTML = (matches||[]).map(m=>{
        const sets = (setMap.get(m.id)||[]).sort((a,b)=>a.set_no-b.set_no);
        const ss   = summarizeState(m, sets);
        const scoreInputs = setInputsInline(m, sets);
        const a = tmap.get(m.team_a_id) || ("#"+m.team_a_id);
        const b = tmap.get(m.team_b_id) || ("#"+m.team_b_id);
        return `
          <tr data-match-id="${m.id}" data-bo="${m.best_of||1}" data-ptw="${m.points_to_win||25}">
            <td class="p-2">#${m.id}</td>
            <td class="p-2">${(m.stage||"").toUpperCase()}${m.is_final?' <span class="text-[10px] chip-success px-1 py-0.5 rounded ml-1">í™•ì •</span>':''}</td>
            <td class="p-2">${m.group_id?((m.groups?.name||m.group_id)) + " ì¡° ": "-"}</td>
            <td class="p-2 whitespace-normal break-keep leading-5"> ${a} <span class="text-slate-400">vs</span> ${b} </td>
            <td class="p-2">
              ${scoreInputs}
              <div class="mt-1 flex flex-wrap gap-1">
                <button class="px-2 py-1 rounded btn-outline text-xs" onclick="saveScores(${m.id})">ğŸ’¾ ì €ì¥</button>
                <button class="px-2 py-1 rounded text-xs" style="border:1px solid var(--danger-700);color:var(--danger-700)" onclick="clearScores(${m.id})">ğŸ§½ ì§€ìš°ê¸°</button>
                <button class="px-2 py-1 rounded text-xs" onclick="walkover(${m.id},'A')">A ë¶€ì „ìŠ¹</button>
                <button class="px-2 py-1 rounded text-xs" onclick="walkover(${m.id},'B')">B ë¶€ì „ìŠ¹</button>
              </div>
            </td>
            <td class="p-2">${rowStateChip(ss)}</td>
            <td class="p-2">
              <input type="number" value="${m.court_no||""}" class="w-16 rounded border brand-card px-2 py-1 text-sm" onchange="updateCourt(${m.id}, this.value)" />
              <select class="rounded border brand-card px-2 py-1 text-xs mt-1" onchange="updateStatus(${m.id}, this.value)">
                ${["pending","live","done"].map(s=>`<option value="${s}" ${m.status===s?"selected":""}>${s}</option>`).join("")}
              </select>
            </td>
            <td class="p-2">
              <button class="px-2 py-1 rounded btn-outline text-xs" onclick="markFinal(${m.id}, true)">ì™„ë£Œ</button>
              <button class="ml-1 px-2 py-1 rounded btn-outline text-xs" onclick="markFinal(${m.id}, false)">í•´ì œ</button>
              <button class="ml-1 px-2 py-1 rounded btn-primary text-xs" onclick="openInRef(${m.id})">ì‹¬íŒì—´ê¸°</button>
            </td>
          </tr>`;
      }).join("");

      // ===== 2-2) ëª¨ë°”ì¼ ì¹´ë“œ =====
      $("#matchesCards").innerHTML = (matches||[]).map(m=>{
        const sets = (setMap.get(m.id)||[]).sort((a,b)=>a.set_no-b.set_no);
        const ss   = summarizeState(m, sets);
        const scoreInputs = setInputsInline(m, sets);
        const a=tmap.get(m.team_a_id)||("#"+m.team_a_id);
        const b=tmap.get(m.team_b_id)||("#"+m.team_b_id);
        const grp = m.group_id?("ì¡° "+(m.groups?.name||m.group_id)):"-";
        return `
          <div class="rounded-2xl border brand-card bg-white p-3 shadow-sm"
              data-match-id="${m.id}" data-bo="${m.best_of||1}" data-ptw="${m.points_to_win||25}">
            <div class="flex items-center justify-between gap-2">
              <div class="text-[11px] text-slate-500">${(m.stage||"").toUpperCase()} Â· ${grp} Â· #${m.id}</div>
              <div class="shrink-0">${rowStateChip(ss)}</div>
            </div>

            <div class="mt-1 font-medium">${a} <span class="text-slate-400">vs</span> ${b}</div>
            <div class="mt-1 text-[11px] text-slate-500">
              BO${m.best_of||1} Â· ${m.points_to_win}${m.court_no?` Â· ì½”íŠ¸ ${m.court_no}`:""}${m.is_final?' Â· âœ…í™•ì •':''}
            </div>

            <div class="mt-2">${scoreInputs}</div>

            <div class="mt-2 grid grid-cols-2 gap-2">
              <button class="rounded px-3 py-2 btn-outline text-xs" onclick="saveScores(${m.id})">ğŸ’¾ ì €ì¥</button>
              <button class="rounded px-3 py-2 text-xs" style="border:1px solid var(--danger-700);color:var(--danger-700)" onclick="clearScores(${m.id})">ğŸ§½ ì§€ìš°ê¸°</button>
              <button class="rounded px-3 py-2 text-xs" onclick="walkover(${m.id},'A')">A ë¶€ì „ìŠ¹</button>
              <button class="rounded px-3 py-2 text-xs" onclick="walkover(${m.id},'B')">B ë¶€ì „ìŠ¹</button>

              <input type="number" value="${m.court_no||""}" placeholder="ì½”íŠ¸"
                    class="col-span-1 w-full rounded border brand-card px-2 py-1 text-xs"
                    onchange="updateCourt(${m.id}, this.value)" />
              <select class="col-span-1 rounded border brand-card px-2 py-1 text-xs"
                      onchange="updateStatus(${m.id}, this.value)">
                ${["pending","live","done"].map(s=>`<option value="${s}" ${m.status===s?"selected":""}>${s}</option>`).join("")}
              </select>

              <button class="col-span-1 rounded px-3 py-2 btn-outline text-xs" onclick="markFinal(${m.id}, true)">ì™„ë£Œ</button>
              <button class="col-span-1 rounded px-3 py-2 btn-outline text-xs" onclick="markFinal(${m.id}, false)">í•´ì œ</button>
              <button class="col-span-2 rounded px-3 py-2 btn-primary text-xs" onclick="openInRef(${m.id})">ì‹¬íŒ í™”ë©´ ì—´ê¸°</button>
            </div>
          </div>`;
      }).join("");
    }
    async function createGroupRoundRobin(){
      const ptw=parseInt($("#defaultPtw").value||"25",10);
      const bo =1;
      const wb =parseInt($("#defaultWinBy").value||"1",10);
      startSaving();
      try{
        const {data:groups}=await sb.from("groups").select("*").order("name");
        if(!groups?.length){ alert("ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤."); return; }
        const {data:gt}=await sb.from("group_teams").select("group_id, team_id").order("group_id");
        const by=new Map(); for(const g of groups) by.set(g.id,[]);
        for(const r of gt||[]) by.get(r.group_id).push(r.team_id);
        let rows=[];
        for(const g of groups){
          const ids=by.get(g.id); if(!ids||ids.length<3) continue;
          for(const [a,b] of rrPairs(ids)){
            rows.push({stage:"group", group_id:g.id, team_a_id:a, team_b_id:b, best_of:bo, points_to_win:ptw, win_by:wb, cap:null});
          }
        }
        if(rows.length) await sb.from("matches").insert(rows);
      } finally { endSaving(); await loadMatches(); }
    }

    // KO ì‚­ì œ(ì•ˆì „)
    async function deleteKOMatches(){
      const {data:ko}=await sb.from("matches").select("id").in("stage",["qf","sf","final"]);
      if(ko?.length){
        const ids=ko.map(m=>m.id);
        await sb.from("match_sets").delete().in("match_id", ids);
        await sb.from("matches").delete().in("id", ids);
      }
    }

    // ===== ìˆœìœ„ ê³„ì‚°: ì„œë²„ë·° ì‹¤íŒ¨ ì‹œ H2H tie-break í¬í•¨ =====
    async function fetchStandings(){
      const advPerGroup = parseInt(document.getElementById('koAdvPerGroup')?.value || '1', 10) || 1;

      const {data, error}=await sb
        .from("v_group_ranked")
        .select("team_id, team_name, group_name, group_rank, win, loss, set_diff, point_diff, pts_for, h2h_win_pct")
        .lte("group_rank", advPerGroup)
        .order("group_name",{ascending:true})
        .order("group_rank",{ascending:true});
      if(!error && data?.length) return data;

      // Fallback with H2H tie-break among tied subset
      const [{data:groups},{data:gteams},{data:matches},{data:msets},{data:teams}] = await Promise.all([
        sb.from("groups").select("*"),
        sb.from("group_teams").select("group_id, team_id"),
        sb.from("matches").select("*").eq("stage","group"),
        sb.from("match_sets").select("match_id,set_no,score_a,score_b"),
        sb.from("teams").select("id,name")
      ]);

      const gName=new Map((groups||[]).map(g=>[g.id,g.name]));
      const tName=new Map((teams||[]).map(t=>[t.id,t.name]));
      const inGroup=new Map(); for(const gt of gteams||[]){ if(!inGroup.has(gt.group_id)) inGroup.set(gt.group_id,new Set()); inGroup.get(gt.group_id).add(gt.team_id); }
      const setsByMatch=new Map(); for(const s of msets||[]){ if(!setsByMatch.has(s.match_id)) setsByMatch.set(s.match_id,[]); setsByMatch.get(s.match_id).push(s); }

      const stats=new Map(); // gid -> tid -> stat
      const ensure=(gid,tid)=>{ if(!stats.has(gid)) stats.set(gid,new Map()); if(!stats.get(gid).has(tid)) stats.get(gid).set(tid,{win:0,loss:0,set_diff:0,point_diff:0,pts_for:0}); return stats.get(gid).get(tid); };

      for(const m of matches||[]){
        if(!m.group_id) continue;
        const sets=setsByMatch.get(m.id)||[];
        let swA=0, swB=0, pfA=0, pfB=0;
        for(const s of sets){ if(s.score_a==null||s.score_b==null) continue; pfA+=+s.score_a||0; pfB+=+s.score_b||0; if(s.score_a>s.score_b) swA++; else if(s.score_b>s.score_a) swB++; }
        if(swA===0&&swB===0&&pfA===0&&pfB===0) continue;
        const A=ensure(m.group_id,m.team_a_id), B=ensure(m.group_id,m.team_b_id);
        A.set_diff+=(swA-swB); B.set_diff+=(swB-swA); A.point_diff+=(pfA-pfB); B.point_diff+=(pfB-pfA); A.pts_for+=pfA; B.pts_for+=pfB;
        if(swA>swB){ A.win++; B.loss++; } else if(swB>swA){ B.win++; A.loss++; }
      }

      const rows=[];
      for(const [gid,tmap] of stats){
        for(const tid of (inGroup.get(gid)||[])) if(!tmap.has(tid)) tmap.set(tid,{win:0,loss:0,set_diff:0,point_diff:0,pts_for:0});

        // 1ì°¨ ì •ë ¬
        let arr=Array.from(tmap.entries()).map(([tid,s])=>({tid,...s}));
        arr.sort((x,y)=> y.win-x.win || y.set_diff-x.set_diff || y.point_diff-x.point_diff || y.pts_for-x.pts_for);

        // ë™ë¥  ì¡°í•©ì— ëŒ€í•´ H2H ì¬ì •ë ¬
        let i=0;
        while(i<arr.length){
          let j=i+1;
          while(j<arr.length && arr[j].win===arr[i].win && arr[j].set_diff===arr[i].set_diff && arr[j].point_diff===arr[i].point_diff && arr[j].pts_for===arr[i].pts_for) j++;
          if(j-i>1){
            const tied=arr.slice(i,j).map(x=>x.tid);
            const h2hWins=new Map(tied.map(t=>[t,0]));
            for(const m of (matches||[])){
              if(m.group_id!==gid) continue;
              if(!tied.includes(m.team_a_id) || !tied.includes(m.team_b_id)) continue;
              const ss=(setsByMatch.get(m.id)||[]);
              let wa=0, wb=0; for(const s of ss){ if(s.score_a>s.score_b) wa++; else if(s.score_b>s.score_a) wb++; }
              if(wa>wb) h2hWins.set(m.team_a_id, h2hWins.get(m.team_a_id)+1);
              else if(wb>wa) h2hWins.set(m.team_b_id, h2hWins.get(m.team_b_id)+1);
            }
            arr.splice(i, j-i, ...arr.slice(i,j).sort((x,y)=> (h2hWins.get(y.tid)-h2hWins.get(x.tid))));
          }
          i=j;
        }

        arr.slice(0, advPerGroup).forEach((it,idx)=>{
          rows.push({team_id:it.tid, team_name:tName.get(it.tid)||("#"+it.tid), group_name:gName.get(gid)||"?", group_rank:idx+1});
        });
      }
      return rows;
    }

    // KO ìƒì„±
    async function createKnockoutFromStandings(){
      const advPerGroup = parseInt(document.getElementById('koAdvPerGroup')?.value || '1', 10) || 1;
      const ptw=parseInt($("#defaultPtw").value||"25",10);
      const bo =parseInt($("#defaultBo").value||"1",10);
      const wb =parseInt($("#defaultWinBy").value||"1",10);

      const SEED_ORDER={2:[0,1],4:[0,3,2,1],8:[0,7,3,4,1,6,2,5]};
      const PAIRS={4:[[0,3],[2,1]],8:[[0,1],[2,3],[4,5],[6,7]]};

      startSaving();
      try{
        const ranks = await fetchStandings(advPerGroup);
        if(!ranks.length){ alert("ìˆœìœ„ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (ì¡°ë³„ ê²°ê³¼ë¥¼ ë¨¼ì € ì €ì¥í•˜ì„¸ìš”)"); return; }

        // ìˆ˜ë™ ì‹œë“œ ìš°ì„  ì ìš© (íŒ€ID ì½¤ë§ˆ)
        const manualText = ($("#manualSeeds").value||"").trim();
        let seeds=null;
        if(manualText){
          seeds = manualText.split(",").map(s=>parseInt(s.trim(),10)).filter(Boolean);
        } else {
          const byGroup=new Map(); for(const r of ranks){ if(!byGroup.has(r.group_name)) byGroup.set(r.group_name,[]); const arr=byGroup.get(r.group_name); if(arr.length<advPerGroup) arr.push(r); }
          seeds = Array.from(byGroup.values()).flat().map(r=>r.team_id);
        }
        if(seeds.length<2){ alert(`ì‹œë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤(í˜„ì¬ ${seeds.length}íŒ€).`); return; }

        // ê¸°ì¡´ KO ì •ë¦¬
        await deleteKOMatches();

        const N=seeds.length, S=(N<=2)?2:(N<=4?4:8);
        const order=SEED_ORDER[S];
        const slots=new Array(S).fill(null);
        for(let i=0;i<Math.min(N,S);i++) slots[order[i]] = seeds[i];

        if(S===2){
          await sb.from("matches").insert([{ stage:"final", team_a_id:slots[0]??null, team_b_id:slots[1]??null, best_of:bo, points_to_win:ptw, win_by:wb, cap:null, status:"pending" }]);
        } else if(S===4){
          const finalists=[]; const sfRows=[];
          for(const [i,j] of PAIRS[4]){
            const a=slots[i], b=slots[j];
            if(a&&b) sfRows.push({stage:"sf", team_a_id:a, team_b_id:b, best_of:bo, points_to_win:ptw, win_by:wb, cap:null, status:"pending"});
            else if(a||b) finalists.push(a||b);
          }
          if(sfRows.length) await sb.from("matches").insert(sfRows);
          if(finalists.length===2){
            await sb.from("matches").insert([{stage:"final", team_a_id:finalists[0], team_b_id:finalists[1], best_of:bo, points_to_win:ptw, win_by:wb, cap:null, status:"pending"}]);
          }
        } else { // 8
          const qfPairs=PAIRS[8]; const qfRows=[]; const halfA=[]; const halfB=[];
          for(let p=0;p<qfPairs.length;p++){
            const [i,j]=qfPairs[p]; const a=slots[i], b=slots[j];
            if(a&&b){ qfRows.push({stage:"qf", team_a_id:a, team_b_id:b, best_of:bo, points_to_win:ptw, win_by:wb, cap:null, status:"pending"}); }
            else if(a||b){ (p<2?halfA:halfB).push(a||b); }
          }
          if(qfRows.length) await sb.from("matches").insert(qfRows);
          const sfRows=[]; if(halfA.length===2) sfRows.push({stage:"sf", team_a_id:halfA[0], team_b_id:halfA[1], best_of:bo, points_to_win:ptw, win_by:wb, cap:null, status:"pending"});
          if(halfB.length===2) sfRows.push({stage:"sf", team_a_id:halfB[0], team_b_id:halfB[1], best_of:bo, points_to_win:ptw, win_by:wb, cap:null, status:"pending"});
          if(sfRows.length) await sb.from("matches").insert(sfRows);
        }

        alert(`ëŒ€ì§„ ìƒì„± ì™„ë£Œ! (ì‹œë“œ ${N}íŒ€)`);
      } catch(e){ console.error(e); alert("ìƒì„± ì‹¤íŒ¨: "+(e.message||e)); }
      finally{ endSaving(); await loadMatches(); }
    }

    // ê¸°íƒ€
    async function wipeMatches(){ if(!confirm("ëª¨ë“  ê²½ê¸° ë° ì„¸íŠ¸ ì ìˆ˜ë¥¼ ì‚­ì œí•©ë‹ˆê¹Œ?")) return; startSaving(); try{ await sb.from("match_sets").delete().neq("match_id",-1); await sb.from("matches").delete().neq("id",-1); } finally{ endSaving(); await loadMatches(); } }
    async function updateCourt(mid,val){ await sb.from("matches").update({court_no:(val?parseInt(val,10):null)}).eq("id",mid); }
    async function updateStatus(mid,status){ await sb.from("matches").update({status}).eq("id",mid); }
    async function markFinal(mid,flag){ await sb.from("matches").update({is_final:!!flag}).eq("id",mid); }
    function openInRef(mid){ location.href=`./referee.html?match=${mid}`; }
    window.updateCourt=updateCourt; window.updateStatus=updateStatus; window.markFinal=markFinal; window.openInRef=openInRef;
    window.saveScores=saveScores; window.clearScores=clearScores; window.walkover=walkover;

    // ===== Mode / Reset / Realtime / Bootstrap =====
    async function hardReset(){
      const key=$("#hardResetKey").value.trim() || $("#adminSecret").value.trim();
      if(!key){ alert("ë¹„ë°€í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”."); return; }
      if(!confirm("ì •ë§ ì „ì²´ ì‚­ì œ/ì´ˆê¸°í™” í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")) return;
      startSaving();
      try{
        const {error}=await sb.rpc("admin_reset_all",{p_secret:key});
        if(error){ console.error(error); alert("ì‹¤íŒ¨: "+(error.message||"ê¶Œí•œ/ë¹„ë°€í‚¤ë¥¼ í™•ì¸í•˜ì„¸ìš”.")); return; }
        await loadTeams(); await loadGroups(); await loadMatches(); alert("ì´ˆê¸°í™” ì™„ë£Œ!");
      } finally { endSaving(); }
    }
    async function switchMode(mode){
      const key=$("#adminSecret").value.trim() || $("#hardResetKey").value.trim();
      if(!key){ alert("ê´€ë¦¬ì ë¹„ë°€í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”."); return; }
      if(!confirm(`ì •ë§ '${mode}' ëª¨ë“œë¡œ ì „í™˜í• ê¹Œìš”?`)) return;
      startSaving();
      try{
        const {data,error}=await sb.rpc("admin_set_mode",{p_mode:mode,p_secret:key});
        if(error){ console.error(error); alert("ì‹¤íŒ¨: "+(error.message||"")); return; }
        alert(`ëª¨ë“œ ì „í™˜ ì™„ë£Œ: ${data}`);
      } finally { endSaving(); }
    }
    function subscribeRealtime(){
      sb.channel("admin")
        .on("postgres_changes",{event:"*",schema:"public",table:"teams"},loadTeams)
        .on("postgres_changes",{event:"*",schema:"public",table:"team_members"},loadTeams)
        .on("postgres_changes",{event:"*",schema:"public",table:"players"},loadTeams)
        .on("postgres_changes",{event:"*",schema:"public",table:"groups"},loadGroups)
        .on("postgres_changes",{event:"*",schema:"public",table:"group_teams"},loadGroups)
        .on("postgres_changes",{event:"*",schema:"public",table:"matches"},loadMatches)
        .on("postgres_changes",{event:"*",schema:"public",table:"match_sets"},loadMatches)
        .subscribe();
    }

    // Bootstrap
    (async()=>{
      try{
        startPage();
        document.getElementById("btnHardReset").addEventListener("click",hardReset);
        document.getElementById("btnModeDev").addEventListener("click",()=>switchMode("dev"));
        document.getElementById("btnModeProd").addEventListener("click",()=>switchMode("prod"));
        document.getElementById("btnAutoGroups").addEventListener("click",autoGroups);
        document.getElementById("btnWipeGroups").addEventListener("click",wipeGroups);
        document.getElementById("btnRR").addEventListener("click",createGroupRoundRobin);
        document.getElementById("btnKO").addEventListener("click",()=>createKnockoutFromStandings());
        document.getElementById("btnWipeMatches").addEventListener("click",wipeMatches);
        document.getElementById("btnBulk").addEventListener("click",openBulk);
        await loadTeams(); await loadGroups(); await loadMatches(); subscribeRealtime();
      } finally { endPage(); }
    })();
  </script>
</body>
</html>
